[{"title":"openresty(动态)添加nginx模块","date":"2018-12-12T07:35:31.000Z","path":"2018/12/12/2018-12-12-openrestry-nginx-http2-module/","text":"换了服务器后，重新搭建了nginx环境，这次使用的是openrestry。在配置https，开启http2的过程中，发现缺少ngx_http_v2_module这个nginx模块。那么如果添加这个模块呢？ 在网上查了一番，大概都是重新编译。顺着这个思路来实践下。 首先查看下我们已经安装的模块123456$ -Vnginx version: openresty/1.13.6.1built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)built with OpenSSL 1.0.2g 1 Mar 2016TLS SNI support enabledconfigure arguments: --prefix=/usr/local/openresty/nginx --with-cc-opt=-O2 --add-module=../ngx_devel_kit-0.3.0 --add-module=../echo-nginx-module-0.61 --add-module=../xss-nginx-module-0.05 --add-module=../ngx_coolkit-0.2rc3 --add-module=../set-misc-nginx-module-0.31 --add-module=../form-input-nginx-module-0.12 --add-module=../encrypted-session-nginx-module-0.07 --add-module=../srcache-nginx-module-0.31 --add-module=../ngx_lua-0.10.11 --add-module=../ngx_lua_upstream-0.07 --add-module=../headers-more-nginx-module-0.33 --add-module=../array-var-nginx-module-0.05 --add-module=../memc-nginx-module-0.18 --add-module=../redis2-nginx-module-0.14 --add-module=../redis-nginx-module-0.3.7 --add-module=../rds-json-nginx-module-0.15 --add-module=../rds-csv-nginx-module-0.08 --add-module=../ngx_stream_lua-0.0.3 --with-ld-opt=-Wl,-rpath,/usr/local/openresty/luajit/lib --with-stream --with-stream_ssl_module --with-http_ssl_module 确实没有http2相关模块 之前安装openrestry就是下载源码编译安装的，切换到openrestry源码目录，重新编译，带上模块参数1$ ./configure --with-ngx_http_v2_module -j2 结果会报错，openrestry没有ngx_http_v2_module这个模块，根据提示，执行./configure --help，可以查看到支持哪些模块。在现实的列表中发现，openrestry的http2模块是http_v2_module，执行如下命令，重新编译1./configure --with-http_v2_module -j2 然后执行make操作1$ make 完成后会有如下提示（版本号显示为自己安装的对应版本号）123...make[2]: Leaving directory &apos;soft/openresty-1.13.6.1/build/nginx-1.13.6&apos;make[1]: Leaving directory &apos;soft/openresty-1.13.6.1/build/nginx-1.13.6&apos; 重新编译后的nginx的二进制文件就在上面提示的目录下面的objs下面，查看下系统环境的nginx在哪12$ which nginx/usr/local/openresty/nginx/sbin/nginx 拷贝编译后的nginx二进制文件覆盖系统环境的nginx，并重启nginx服务12$ nginx -s stop$ cp soft/openresty-1.13.6.1/build/nginx-1.13.6/objs/nginx /usr/local/openresty/nginx/sbin/ 再看看nginx配置12345678910111213141516171819202122232425server &#123; listen 80; #listen[::]:80; #SSL configuration listen 443 ssl http2; #listen [::]443 ssl http2; ##ssl on; ssl_certificate /etc/letsencrypt/live/frontjs.cc/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/frontjs.cc/privkey.pem; root /www/html; index index.html index.htm index; server_name frontjs.cc; #force https #rewrite ^(.*)$ https://$host$1 permanent; location / &#123; try_files $uri $uri/ =404; #proxy_pass http://127.0.0.1:8000; &#125;&#125; 现在执行nginx -t就不会报缺少模块的错误了 启动nginx服务1$ nginx Done~ 参考https://openresty.org/en/installation.html","tags":[{"name":"nginx","slug":"nginx","permalink":"https://yl.frontjs.cc/tags/nginx/"}]},{"title":"内网服务穿透 - ngrok搭建","date":"2018-11-12T07:35:31.000Z","path":"2018/11/12/2018-11-12-ngrok/","text":"微信开发时，本地服务调试域名的问题，遂搭建ngrok，内网穿透。很久以前搭建的，现整理到博客里，方便以后查阅 1234# ubuntu 16参考：https://imququ.com/post/self-hosted-ngrokd.htmlhttp://linfuyan.com/ubuntu-ngrok/ ecs域名解析12A记录 ngrok.frontjs.ccCNAME *.ngrok.frontjs.cc -&gt; ngrok.frontjs.cc 安装依赖 sudo apt-get install build-essential golang mercurial1234567891011# 备注：阿里云上默认装的golang是1.6，编译出的文件在mac上报错，可采用源码编译安装golanggolang版本地址：`https://golang.org/dl/`wget -c https://dl.google.com/go/go1.10.linux-amd64.tar.gztar -C /usr/local -zxvf go1.10.linux-amd64.tar.gz# 配置环境变量echo &apos;export GOROOT=/usr/local/go&apos; &gt;&gt; /etc/profileecho &apos;export PATH=$PATH:$GOROOT/bin&apos; &gt;&gt; /etc/profileecho &apos;export GOPATH=$HOME/go&apos; &gt;&gt; /etc/profileecho &apos;export GOROOT_BOOTSTRAP=/usr/local/go&apos; &gt;&gt; /etc/profilesource /etc/profile 下载源码12git clone https://github.com/inconshreveable/ngrok.git ngrokcd ngrok 生成并替换源码里默认的证书1234567891011NGROK_DOMAIN=&quot;ngrok.frontjs.cc&quot;openssl genrsa -out base.key 2048openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out base.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csropenssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crtcp base.pem assets/client/tls/ngrokroot.crtcp server.crt assets/server/tls/snakeoil.crtcp server.key assets/server/tls/snakeoil.key 编译包1234GOOS=linux GOARCH=amd64 make release-server release-clientGOOS=darwin GOARCH=amd64 make release-clientGOOS=windows GOARCH=amd64 make release-client# 编译后的文件在 bin/，ngroked 为服务器使用，其他拷贝到对应客户端使用 启动服务1234./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;ngrok.frontjs.cc&quot; -httpAddr=&quot;:7098&quot; -httpsAddr=&quot;:7099&quot;# 后台运行nohup ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;ngrok.frontjs.cc&quot; -httpAddr=&quot;:7098&quot; -httpsAddr=&quot;:7099&quot; &amp; 配置并启动客户端1234567891011121314151617# vim ngrok.cfgserver_addr: ngrok.frontjs.cc:4443trust_host_root_certs: false# 指定子域名./ngrok -subdomain test -proto=http -config=ngrok.cfg 7001# 随机子域名./ngrok -proto=http -config=ngrok.cfg 7001# 打印如下信息Tunnel Status onlineVersion 1.7/1.7Forwarding http://test.ngrok.frontjs.cc:7098 -Web Interface 127.0.0.1:4040# Conn 0Avg Conn Time 0.00ms nginx 转发配置到这里没遇到问题，那么就可以通过http://test.ngrok.frontjs.cc:7098来访问本地7001端口的服务了，下面配置nginx来忽略端口号访问, 添加7098的vhost12345678910111213141516server &#123; listen 80; listen [::]:80; server_name *.ngrok.frontjs.cc; proxy_set_header &quot;Host&quot; $host:7098; root /mnt/portal-cms; index index.html index.htm; location / &#123; proxy_pass_header Server; proxy_pass http://127.0.0.1:7098; proxy_redirect off; &#125;&#125; 重启nginx（service nginx restart）http://test.ngrok.frontjs.cc访问本地7001端口服务 报错及解决方法121. 26958 segmentation fault升级golang到最新版(参考最上面第二个链接，下载源码安装golang)","tags":[{"name":"ngrok","slug":"ngrok","permalink":"https://yl.frontjs.cc/tags/ngrok/"}]},{"title":"mongoose分组查询记录","date":"2018-11-01T07:35:31.000Z","path":"2018/11/01/2018-11-01-mongoose-aggregate-gruop/","text":"mongoose聚合分组(aggregate, group)的简单使用记录，直接上代码 数据模型12345678910111213# model/report.jsmodule.exports = (&#123; Schema, db &#125;, app) =&gt; &#123; const Report = new Schema(&#123; platform: String, cname: String, url: String, floor: String &#125;, &#123; timestamps: true &#125;) return db.model('Report', Report, 'Report')&#125; 以某个字段分组 aggregate group使用：如果需要分组的字段为cname，那么_id对应的值就为$cname 1234567const dataByDate = await this.model('report').aggregate([ &#123; $match: queryCondition &#125;, &#123; $group: &#123; _id: '$cname', count: &#123; $sum: 1 &#125; &#125; &#125;]) 输出结果 1234567891011121314[ &#123; \"_id\": \"title2\", \"count\": 22 &#125;, &#123; \"_id\": \"title3\", \"count\": 8 &#125;, &#123; \"_id\": \"title4\", \"count\": 10 &#125;] 多个维度上面是通过字段cname来分组，如果我们同时想统计每天的每个cname的数量呢？如下，_id里指定两个分组条件，然后使用$project给分组后数据字段重命名，然后继续分组 12345678910111213141516171819202122232425const data = await this.model('report').aggregate([ &#123; $match: queryCondition &#125;, &#123; $group: &#123; _id: &#123; [dimension]: '$' + dimension, date: &#123; $dateToString: &#123; format: '%Y-%m-%d', date: '$createdAt' &#125; &#125; &#125;, count: &#123; $sum: 1 &#125; &#125; &#125;, &#123; $project: &#123; _id: 0, date: '$_id.date', [dimension]: &#123; [dimension]: `$_id.$&#123;dimension&#125;`, count: '$count' &#125; &#125; &#125;, &#123; $group: &#123; _id: '$date', [dimension]: &#123; $push: `$$&#123;dimension&#125;` &#125; &#125; &#125;]) 输出 12345678910111213141516171819202122232425262728[ &#123; \"_id\": \"2018-10-30\", \"cname\": [ &#123; \"cname\": \"title4\", \"count\": 2 &#125; ] &#125;, &#123; \"_id\": \"2018-10-31\", \"cname\": [ &#123; \"cname\": \"title4\", \"count\": 8 &#125;, &#123; \"cname\": \"title3\", \"count\": 8 &#125;, &#123; \"cname\": \"title2\", \"count\": 22 &#125; ] &#125;] 更多用法，参考官方文档 参考 https://docs.mongodb.com/manual/aggregation/ https://mongoosejs.com/docs/api.html#Aggregate","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://yl.frontjs.cc/tags/mongoose/"}]},{"title":"科学上网：vultr搭建shadowsocks采坑记录","date":"2018-10-30T07:35:31.000Z","path":"2018/10/30/2018-10-30-vultr-ss/","text":"说明：网上很多相关教程，大多数是基于centos的，本教程基于Ubuntu(主要是多账号设置) 注册vutrl账号，购买服务器 注册vutrl https://www.vultr.com 新用户注册使用PayPal，充值多少送多少，最多送100刀(果断充值了100刀，后面发现赠送的100刀有效期是1年) 购买服务器，选择最新的Ubuntu，节点选日本东京 配置选最小的，不过$2.5每月的只支持IPV6，不建议选择，我这里选的每月5刀的，选择完后点击deploy now，然后等待服务器配置并启动 启动完成后，在Servers里就可以看到刚才购买的vps了 点击服务器，查看服务器的ip，用户名，以及密码 安装shadowsocks ssh登录服务器，账号密码来源于上图 安装shadowsocks，网上教程很多，这里直接copy过来安装脚本 123$ wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh$ chmod +x shadowsocks.sh$ ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 如上三步执行完成后，中途会让你设置一个密码，选择一个端口，还有选择一个协议(忘了截图了…)，协议我选的第7个aes-256-cfb，等待一会后，shadowsocks就安装好了，控制台可以看到shadowsocks服务的相关信息，大致如下，至此，ss服务就已经可用了 1234Your Server IP : IPYour Server Port : PortYour Password : PasswordYour Encryption Method: aes-256-cfb 安装shadowsocks客户端 ShadowsocksX-NG Mac版 windows版 添加shadowsocks服务器信息 大功告成，可以尝试访问https://www.google.com，然后可以愉快的工作了 TCP加速与多账号配置 打开TCP Fast Open 1$ vim /etc/rc.local 添加如下内容到上面打开的文件 1echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 参照上面方法，添加net.ipv4.tcp_fastopen = 3到/etc/sysctl.conf文件 修改shadowsocks配置文件的fast_open选项为true，参考下面多账号配置里的修改 多账号端口配置：修改shadowsocks配置，配置文件地址为/etc/shadowsocks.json，添加多个端口和对应的密码 12345678910111213141516171819202122232425# 原配置&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125;# 修改后的配置&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;port1&quot;:&quot;psw1&quot;, &quot;port2&quot;:&quot;psw2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:true&#125; 重启shadowsocks服务 1$ /etc/init.d/shadowsocks restart 至此，加速与多账号端口配置就完成了，然后我们在shadowsocks客户端里添加这两个账号，链接试试。惊喜的发现，只有最后配置的那个可以成功连接，前面的连接上后还是会困在墙里。没错，需要修改防火墙的配置 防火墙配置修改 vultr防火墙配置 protocol选择TCP(我同时开启了UDP)，port选择shadowsocks里开启的多个端口，有多少个端口就配置多少个rule(PS: 我看Port旁边显示的or range，不过设置range后无效，有同学可以设置rang的话，麻烦留言指教下，感谢感谢)。rules设置后，在Linked Instances里选择你的实例进行关联 服务器防火墙配置 登录服务器后，控制台安装ufw 1apt-get install ufw allow需要开放的端口 12345$ ufw enable$ ufw default deny$ ufw allow 22/tcp$ ufw allow port1$ ufw allow port2 重启ufw服务 1$ ufw reload 重启shadowsocks服务 1$ /etc/init.d/shadowsocks restart 然后使用shadowsocks客户端连接多个账号，发现都能成功连接了 说明 科学上网，文明上网 如若本教程违反相关法律法规，请联系本人进行删除 参考 科学上网之vultr安装shadowsocks ufw用法","tags":[{"name":"vultr","slug":"vultr","permalink":"https://yl.frontjs.cc/tags/vultr/"},{"name":"vps","slug":"vps","permalink":"https://yl.frontjs.cc/tags/vps/"},{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://yl.frontjs.cc/tags/shadowsocks/"}]},{"title":"GitHub多账号管理踩坑记录","date":"2018-07-24T07:35:31.000Z","path":"2018/07/24/2018-07-24-manage-git-account/","text":"背景 新增了一个Github账号，并push过代码，然后用以前的github账号push时，死活push不上去 寻找解决办法 使用ssh key 每个账号对应一个key, Github上填写对应的key（如：id_rsa.github.yl2014.pub文件内容） 1234567891011121314151617181920212223242526272829# 生成key文件ssh-keygen -t rsa -f ~/.ssh/id_rsa.github.yl2014 -C &quot;yl2014@xx.com&quot;ssh-keygen -t rsa -f ~/.ssh/id_rsa.github.test -C &quot;test@xx.com&quot;# 添加key文件ssh-add ~/.ssh/id_rsa.github.yl2014ssh-add ~/.ssh/id_rsa.github.test# 配置configvim ~/.ssh/configHost yl2014 HostName github.com IdentityFile ~/.ssh/id_rsa.github.yl2014 User gitHost test HostName github.com IdentityFile ~/.ssh/id_rsa.github.test User git# 测试ssh -T yl2014&gt; Hi YL2014! You&apos;ve successfully authenticated, but GitHub does not provide shell access.ssh -T test&gt; Hi test! You&apos;ve successfully authenticated, but GitHub does not provide shell access.ssh -T git@github.com&gt; Hi YL2014! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 如果出现 ermission denied (publickey)，则表示key没添加成功，执行ssh-add ~/.ssh/id_rsa.github.yl2014，或用debug模式查看具体出错信息ssh -vT git@github.com 如果发现推送时一直是某个GitHub账号，无法切换成另一个，可以采取如下操作：123# 删除所有session，并添加需要认证的$ ssh-add -D$ ssh-add id_rsa.github.yl2014 参考：http://www.barretlee.com/blog/2016/03/09/config-in-ssh-after-troubling-git-connection/","tags":[{"name":"git","slug":"git","permalink":"https://yl.frontjs.cc/tags/git/"}]},{"title":"Let's Encrypt 通配符证书配置","date":"2018-03-30T07:35:31.000Z","path":"2018/03/30/2018-03-30-Let's Encrypt https/","text":"本文只是对配置过程的记录，如有问题，欢迎留言 环境与依赖 阿里云ECS ubunt16.0.412345$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install python-certbot-nginx 生成证书1$ certbot -d *.frontjs.cc --server https://acme-v02.api.letsencrypt.org/directory --manual --preferred-challenges dns-01 按提示操作，注意事项如下：注意上面做记号的地方，到了这里先不要Enter，先去阿里云上域名解析哪里添加一条解析添加完成后，新开一个窗口测试下是否成功1$ dig _acme-challenge.frontjs.cc txt 如上图所示，表示成功了然后回到安装的窗口，按EnterOK，证书生成完成 证书有效期3个月，设置定时任务来更新证书 编写定时任务脚本12$ vim /etc/letsencrypt/live/renew.sh# 内容：certbot renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot; 设置定时任务12$ crontab -e# 添加如下内容 0 0 1 * * /etc/letsencrypt/live/renew.sh &gt;/dev/null 2&gt;&amp;1 nginx配置12345678910111213141516171819server &#123; listen 80; listen [::]:80; listen 443 ssl; # ssl off 支持http和https # ssl on; ssl_certificate /etc/letsencrypt/live/frontjs.cc/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/frontjs.cc/privkey.pem; server_name frontjs.cc; # 强制https # rewrite ^(.*)$ https://$host$1 permanent; location / &#123; proxy_pass http://127.0.0.1:7000; &#125;&#125; 重启nginx1$ service nginx restart enjoy yourself!参考https://letsencrypt.org/https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginxhttps://certbot.eff.org/docs/using.html","tags":[{"name":"let's encrype","slug":"let-s-encrype","permalink":"https://yl.frontjs.cc/tags/let-s-encrype/"},{"name":"https","slug":"https","permalink":"https://yl.frontjs.cc/tags/https/"}]},{"title":"ECS上nodejs升级(7.2.0)记录","date":"2016-12-08T09:40:31.000Z","path":"2016/12/08/2016-12-08-ecs-nodejs/","text":"更新：此文作废，用nvm就好了，哪那么多破事… 卸载如果之前是通过 apt-get install nodejs npm安装的，直接执行 apt-get remove nodejs npm -y卸载，若原来是通过源码编译安装的(我之前就是)，参考这个进行卸载https://hungred.com/how-to/completely-removing-nodejs-npm/ 安装 12curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -sudo apt-get install -y nodejs 参考：https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions 是否成功？1234root@yl:/etc# node -v-bash: /usr/local/bin/node: No such file or directoryroot@yl:/etc# npm -v-bash: /usr/local/bin/npm: No such file or directory 很明显没成功(注：在真实的ubuntu里，已经成功了，这个是ECS上显示了) 看看node装在哪了1234root@yl:/etc# which node/usr/bin/noderoot@yl:/etc# which npm/usr/bin/npm 可以看到，其实是安装成功了，只是命令的对应目录不对，这就好办了 软链123456root@yl:/etc# ln -s /usr/bin/nodejs /usr/local/bin/noderoot@yl:/etc# node -vv7.2.0root@yl:/etc# ln -s /usr/bin/npm /usr/local/bin/npmroot@yl:/etc# npm -v3.10.9 可以愉快的玩耍了~~","tags":[{"name":"ecs","slug":"ecs","permalink":"https://yl.frontjs.cc/tags/ecs/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://yl.frontjs.cc/tags/ubuntu/"},{"name":"nodejs","slug":"nodejs","permalink":"https://yl.frontjs.cc/tags/nodejs/"}]},{"title":"ubuntu上搭建ftp服务器","date":"2016-06-13T09:40:15.000Z","path":"2016/06/13/2016-06-13-ubuntu-ftp/","text":"买阿里云的ECS有段时间了，也折腾了一段时间，过段时间写一写折腾的一些东东。昨天有个想法，服务器上已经搭建了一些东西，如果需要合作开发，必然需要给团队的开发人员服务器的账号和密码。但是这里涉及到一个权限问题，比如，当某个项目的前端开发人员只需要将前端代码上传到服务器，就没必要给服务器的所有权限。脑海中第一反应就是ftp了，刚使用ECS也是用ftp来管理文件的。当然，jekins的自动化部署也能解决这样的需求，这个以后有时间在写一篇。 在网上找了一些资料，以及查阅ECS的官方文档，也确实找到了我想要的东西，例如这个Linux下如何进行FTP设置，还有这个ECS Linux配置vsftpd限制FTP账户访问其它目录。 看完这两篇文章，发现没什么好写的，只剩下实践了。所以我打算在本地先测试一遍，如果没问题，然后就在ECS上去添加ftp用户，并设置访问权限，下面开始实践。 按照刚才给出的第一份文档， 1234567root@yl:/# apt-get install vsftpd -yroot@yl:/# useradd -d /usr/yl -m -s /usr/sbin/nologin testroot@yl:/# passwd test输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码root@yl:/# chown -R test.test /usr/yl 然后就是修改vsftpd.conf和shells文件 12root@yl:/# vim /etc/vsftpd.confroot@yl:/# vim /etc/shells shells文件的修改，在文件后面加上/usr/sbin/nologin，vsftpd.conf的关键修改如下， 1234chroot_local_user=YESchroot_list_enable=YES# (default follows)chroot_list_file=/etc/vsftpd.chroot_list 这里简单说明下(来源于网络)：chroot_local_user=YES #是否将所有用户锁定在主目录,YES为启用 NO禁用.(包括注释掉也为禁用)chroot_list_enable=YES #是否启动锁定用户的名单 YES为启用 NO禁用(包括注释掉也为禁用)chroot_list_file=/etc/vsftpd.chroot_list #禁用的列表名单 格式为一行一个用户, 如果名单里面有一个ftpuser的用户, 则ftpuser用户不会锁定在主目录,用户将可以自由切换目录. 然后重启ftp服务 1root@yl:/# service vsftpd restart 尝试连接 12345678root@yl:/usr# ftp 127.0.0.1Connected to 127.0.0.1.220 (vsFTPd 3.0.2)Name (127.0.0.1:yl): test331 Please specify the password.Password:500 OOPS: vsftpd: refusing to run with writable root inside chroot()Login failed. 好吧，看到报500了，哈哈。针对这个问题，chrome了一番，得到的答案是最新的vsftp对受限用户的主目录不能设置writable权限。那么问题来了，我们创建用户并只允许其访问自己的主目录，这里又不能给他可写的权限，好像矛盾了。没错，确实矛盾了。既然官方说了不能给主目录可写权限，那么我们可以给他的子目录可写的权限，用户在子目录里进行对应的操作就可以了，如下 123456root@yl:/# chmod a-w /usr/ylroot@yl:/# cd /usr/ylroot@yl:/usr/yl# mkdir wwwroot@yl:/usr/yl# lswwwroot@yl:/usr/yl# chmod 777 www 我们再来连接试试 12345678910root@yl:/usr# ftp 127.0.0.1Connected to 127.0.0.1.220 (vsFTPd 3.0.2)Name (127.0.0.1:yl): test331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.Using binary mode to transfer files.ftp&gt; 连接成功！ 然后我使用xftp在windows里使用刚才新建的账号连接虚拟机里的服务器也正常连接了，并且只能访问自己的主目录，不能跳出当前目录，权限也跟刚才设置的一样，只能在子目录里上传文档。剩下的就是把这些操作在ECS上copy一次了，如果遇到了新的问题会在留言里贴出，如有疑问，欢迎留言。","tags":[{"name":"linux","slug":"linux","permalink":"https://yl.frontjs.cc/tags/linux/"},{"name":"ecs","slug":"ecs","permalink":"https://yl.frontjs.cc/tags/ecs/"},{"name":"ftp","slug":"ftp","permalink":"https://yl.frontjs.cc/tags/ftp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://yl.frontjs.cc/tags/ubuntu/"}]},{"title":"FormData API 上传文件到又拍云","date":"2016-04-25T09:39:33.000Z","path":"2016/04/25/2016-04-25-upload-pic-upyun/","text":"最近又遇到了上传文件的需求，以前也写过一篇关于利用formdata上传文件的文章(如需浏览，请点击这里)，这次上传的地址是又拍云，在操作过程中稍微遇到了一些坑，这里简单记录下。 这里使用的是又拍云的HTTP FORM API，使用流程大概如下 请求客户服务器，生成、获取上传所需的 signature、policy 参数。为了提升上传成功率（避免签名过期）、安全性(设置尽可能短的授权有效期)，我们建议在每次执行上传操作之前，都重新执行本步骤获取相关参数； 请求 UPYUN API 上传文件，校验返回结果/异步回调通知客户服务器； 处理常规客户业务流程。 没错，我们首先要获取上传到又拍云所需要的字段，这个由自己的服务端返回，然后将这两个参数和文件参数一起请求又拍云的api接口即可，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Utils.ajaxGet('/upload/sign',&#123;mod: 'serverSite'&#125;, function(data)&#123; /*data &#123;\"signature\":xxx, \"policy\":xxxx&#125;*/ upload(data);&#125;);function upload(data)&#123; var file, fd = new FormData(), xhr = new XMLHttpRequest(), loaded, total, pre, url, input; if(document.getElementById('myUploadInput'))&#123; input = document.getElementById('myUploadInput'); &#125;else&#123; input = document.createElement('input'); input.setAttribute('id', 'myUploadInput'); input.setAttribute('type', 'file'); input.setAttribute('name', 'file'); document.body.appendChild(input); input.style.display = 'none'; &#125; url = 'http://v0.api.upyun.com/xxx'; input.click(); input.onchange = function()&#123; file = input.files[0]; fd.append('signature', data.signature); fd.append('policy', data.policy); fd.append('file', file); xhr.open('post', url); xhr.send(fd); xhr.onreadystatechange = function()&#123; console.log(xhr); if(xhr.status == 200)&#123; if(xhr.readyState == 4)&#123; if(option.callback instanceof Function)&#123; console.log(xhr.responseText); if(typeof xhr.responseText == 'string')&#123; option.callback(JSON.parse(xhr.responseText)) &#125;else&#123; option.callback(xhr.responseText); &#125; xhr = null; &#125; &#125; &#125;else&#123; Utils.showTips('上传失败') &#125; &#125;; xhr.upload.onprogress = function(event)&#123; loaded = event.loaded; total = event.total; pre = Math.floor(100 * loaded / total); if(option.uploading instanceof Function)&#123; option.uploading(pre); &#125; &#125; &#125;&#125; 上面代码中url中的xxx，是又拍云配置里的bucket-name，具体的可以查看又拍云的相关api文档。 一切看似很正常，我开始也是这么觉得的，然后，bug发生了。当我们在页面上点击按钮调用上述方法的时候，发现什么也没有发生，按常理应该会打开本地的资源管理器的。然后在控制台看看，发现只向自己的服务端发送了请求，创建的表单元素的change事件没有发生，这个断点可以看到。 为什么change没有发生？初步猜测，ajax发起的网络请求会阻塞或者影响浏览器UI层的渲染，然后谷歌查阅相关资料，也找到了相关的解释。 资料一 资料二 既然找到了原因，解决办法也很明显了，如果使用的jQuery的ajax，可以尝试上述资料里的方法，我这里偷了个懒，从服务端获取signature、policy的方法放到了表单元素的change事件里。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Utils.uploadFile = function (option)&#123; var file, fd = new FormData(), xhr = new XMLHttpRequest(), loaded, total, pre, url, input; if(document.getElementById('myUploadInput'))&#123; input = document.getElementById('myUploadInput'); &#125;else&#123; input = document.createElement('input'); input.setAttribute('id', 'myUploadInput'); input.setAttribute('type', 'file'); input.setAttribute('name', 'file'); document.body.appendChild(input); input.style.display = 'none'; &#125; url = 'http://v0.api.upyun.com/xxx'; input.click(); input.onchange = function()&#123; var fileType = ['gif','png','jpg','jpge']; var type = input.value.split('.').pop(); if(fileType.indexOf(type.toLocaleLowerCase()) == -1)&#123; Utils.showTips('该类型文件不支持，请选择图片文件'); return; &#125; if(option.maxSize &amp;&amp; input.files[0].size &gt; option.maxSize * 1024 * 1024)&#123; Utils.showTips('请上传小于'+option.maxSize+'M的文件'); return; &#125; if(option.beforeSend instanceof Function)&#123; if(option.beforeSend(file) === false)&#123; return false; &#125; &#125; Utils.ajaxGet('/upload/sign',&#123;mod: 'serverSite'&#125;, function(data)&#123; file = input.files[0]; fd.append('signature', data.signature); fd.append('policy', data.policy); fd.append('file', file); xhr.open('post', url); xhr.send(fd); xhr.onreadystatechange = function()&#123; console.log(xhr); if(xhr.status == 200)&#123; if(xhr.readyState == 4)&#123; if(option.callback instanceof Function)&#123; console.log(xhr.responseText); if(typeof xhr.responseText == 'string')&#123; option.callback(JSON.parse(xhr.responseText)) &#125;else&#123; option.callback(xhr.responseText); &#125; xhr = null; &#125; &#125; &#125;else&#123; Utils.showTips('上传失败') &#125; &#125;; xhr.upload.onprogress = function(event)&#123; loaded = event.loaded; total = event.total; pre = Math.floor(100 * loaded / total); if(option.uploading instanceof Function)&#123; option.uploading(pre); &#125; &#125; &#125;); &#125;&#125; 这就完了？ 其实并没有，还遇到一个奇葩问题，也就是刚才说的change事件没发生的时候，请求又拍云拿到的xhr.status为0，可能是我孤陋寡闻了，还没听过状态码可以为0。只能说明谷歌很强大，马上就找到相关资料了，因为没有send。最开始的时候，又拍云的请求路径错了也拿到了为0的status，以后遇到类似的情况可以从这几个方面去查找原因了。 上传文件到又拍云后，又拍云接口的返回参数里有个url，具体的文件访问路径为 &quot;http://xxx.b0.upaiyun.com/&quot;+url，xxx为bucket-name，相关文档可以看这里。 差不多就这么多了，如有疑问欢迎留言。","tags":[{"name":"js","slug":"js","permalink":"https://yl.frontjs.cc/tags/js/"},{"name":"又拍云","slug":"又拍云","permalink":"https://yl.frontjs.cc/tags/又拍云/"}]},{"title":"微信jssdk使用记录","date":"2016-04-11T09:39:13.000Z","path":"2016/04/11/2016-04-11-wx-use/","text":"话说接触微信开发是毕业前的第一份工作，当时所做的就是一些微信上的活动推广页面，用到的jssdk就只有微信分享跟网页登录授权吧。记得很久以前微信分享是不需要后端支持的，后来世界变了，不能只靠前端来拯救世界了… 最近的项目就是微信端的，首先用到的就是jssdk。下面整理几个，还没用上的等用上了再来补充。 首先贴上微信jssdk地址：http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html 初始配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546function wxConfig(option)&#123; wx.config(&#123; debug: false, appId: option.appId, timestamp: option.timestamp, nonceStr: option.nonceStr, signature: option.signature, jsApiList: [ 'onMenuShareTimeline', 'onMenuShareAppMessage', 'onMenuShareQQ', 'onMenuShareWeibo', 'onMenuShareQZone', 'startRecord', 'stopRecord', 'onVoiceRecordEnd', 'playVoice', 'pauseVoice', 'stopVoice', 'onVoicePlayEnd', 'uploadVoice', 'downloadVoice', 'chooseImage', 'previewImage', 'uploadImage', 'downloadImage', 'translateVoice', 'getNetworkType', 'openLocation', 'getLocation', //获取位置信息 'hideOptionMenu', 'showOptionMenu', 'hideMenuItems', 'showMenuItems', 'hideAllNonBaseMenuItem', 'showAllNonBaseMenuItem', 'closeWindow', 'scanQRCode', 'chooseWXPay', //支付 'openProductSpecificView', 'addCard', 'chooseCard', 'openCard' ] &#125;);&#125; 有 option 的参数是后端给的，具体的后端实现可以参考微信的官方demo 获取位置信息12345678910111213141516171819202122232425function getLocation()&#123; wx.ready(function()&#123; wx.getLocation(&#123; type: 'gcj02', success: function (data) &#123; var res = data; if(data.res)&#123; res = data.res; &#125; var latitude = res.latitude; var longitude = res.longitude; Utils.setData('position',JSON.stringify(&#123; latitude: latitude, longitude: longitude &#125;)); //if(latitude &amp;&amp; longitude)&#123; getDetailAddr(latitude, longitude); //&#125; &#125;, fail: function(res)&#123; page.location = page.locationFailTip; &#125; &#125;); &#125;);&#125; 以上代码通过微信拿到经纬度后，向后端发起请求拿详细地址(想前端自己拿详细地址，可以借助于百度地图的api，百度地图在微信里能否使用还没做尝试) 微信支付1234567891011121314151617function wxPays(option)&#123; wx.ready(function()&#123; wx.chooseWXPay(&#123; timestamp: option.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: option.nonceStr, // 支付签名随机串，不长于 32 位 package: option.package, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=***） signType: option.signType, // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: option.paySign, // 支付签名 success: function (res) &#123; // 支付成功后的回调函数,请求服务器查询支付结果 var prepayId = option.package.split('=')[1]; checkPayResult(prepayId); &#125;, fail: function(res)&#123;&#125; &#125;); &#125;);&#125; 以上带option的参数需服务端提供，发起微信支付后，会自动调出微信支付的面板，完成支付或取消支付会进入相应的回调，根据微信官方提供的支付文档(业务流程说明)，支付完成后，服务端需确认是否支付成功，所以我们还得向服务端发送一次支付结果确认请求。 当时调支付时一个很小的错误导致支付面板没弹出，就使用了支付文档里的示例demo，如下 123456789101112131415161718192021222324252627282930313233343536373839404142function wxPays(option)&#123; //alert('微信支付配置参数:'+JSON.stringify(option)); onBridgeReady(option); function onBridgeReady(option)&#123; WeixinJSBridge.invoke( 'getBrandWCPayRequest', &#123; \"appId\" : option.appId, //公众号名称，由商户传入 \"timeStamp\" : option.timeStamp, //时间戳，自1970年以来的秒数 \"nonceStr\" : option.nonceStr, //随机串 \"package\" : option.package, \"signType\" : option.signType, //微信签名方式： \"paySign\" : option.paySign //微信签名 &#125;, function(res)&#123; // 使用以上方式判断前端返回,微信团队郑重提示：res.err_msg将在用户支付成功后返回 ok，但并不保证它绝对可靠。 //if(/ok/.test(res.err_msg)) &#123; if(res.err_msg == \"get_brand_wcpay_request:ok\") &#123; var prepayId = option.package.split('=')[1]; checkPayResult(prepayId); &#125;else&#123; Utils.alert(&#123; title: '懂师傅提示您', content: '支付失败，请重新支付', callback: function()&#123; window.location.reload(); &#125; &#125;); &#125; &#125; ); &#125; if (typeof WeixinJSBridge == \"undefined\")&#123; if( document.addEventListener )&#123; document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); &#125;else if (document.attachEvent)&#123; document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); &#125; &#125;else&#123; onBridgeReady(); &#125;&#125; 该方法在android机上测试是有效的，在ios机上测试是提示调用jsApi时没有传timeStamp，不知道是什么鬼，哪位朋友知道怎么解决的，欢迎留言告知，不胜感谢 选择图片与上传图片选择图片12345678910111213141516171819function uploadImage()&#123; wx.ready(function()&#123; wx.chooseImage(&#123; count: 3-page.photos.length, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 localIds.forEach(function(item)&#123; if(page.photos.indexOf(item) == -1)&#123; page.photos.push(item); uploadToWx(item); &#125; &#125;) &#125;, fail: function(res)&#123;&#125; &#125;); &#125;);&#125; 上传图片123456789function uploadToWx(localId)&#123; wx.uploadImage(&#123; localId: localId, // 需要上传的图片的本地ID，由chooseImage接口获得 isShowProgressTips: 0, // 默认为1，显示进度提示 success: function (res) &#123; page.serverIds.push(res.serverId); // 返回图片的服务器端ID &#125; &#125;);&#125; 感觉微信提供的能够调用手机拍照和相册的方法蛮实用的，一般这个在app里才能实现，浏览器一般也只能选择文件。选择了图片后，可以在回调里拿到图片的id列表,本地的图片id在微信里是可以用来显示图片的，通过该id列表的每个id(注意，这里是单个id，不是列表)，就可以调用微信上传图片的接口，将图片上传到微信服务器上，微信服务器目前对图片的保留时间是3天，上传成功后回调里可以拿到serverId，服务端通过serverId将微信服务器上的图片资源下载到自己的服务器或第三方进行存储。 目前用的微信jssdk就这几个，后续有用上会再补上。 下面说下最近开发中遇到的问题，避免以后踩同样的坑。 关于微信里的刷新这个问题困扰了好久，也尝试过很多方法。问题场景：有一个订单状态页面：订单提交成功，接单成功，待支付，支付成功待评价，评价成功。我用了一个页面，通过订单状态值来渲染对应的template，所以用户支付后刷新页面就应该看到待评价的内容，因为支付成功后页面刷新，订单状态值就改变了，评价后刷新是同样的道理。尝试过的方法： window.location.reload(); window.location.href = window.location.href; window.location.href = window.location.href + ‘&amp;r=’ + 时间戳 结果均以失败告终，页面刷新，数据没刷新，通过fiddler查看网络请求发现，刷新页面时没有向服务器拿页面，说明拿的只是缓存，这种情况以前确实没遇到过，及时缓存严重，用时间戳的方法也一般可以解决。后来在一个前端群里求助，得到了解决方法：window.location.reload(true)，传true强制刷新，好吧，看来还是得多看看基础，一直不知道这个方法还有个参数。这里也要感谢群里的那位朋友。 关于js的事件代理以前一直有用js的事件代理，这次场景跟以前稍微有点不同，先看代码 123456789101112131415&lt;ul class=\"equipments-list\" @click=\"toStatusPage($event)\"&gt; &lt;li v-for=\"item in orders\" class=\"equipments-item\" :orderId=\"item.id\"&gt; &lt;p&gt; &lt;span class=\"order-no\" v-text=\"'单号'+item.orderNo\"&gt;&lt;/span&gt; &lt;span class=\"order-status\" v-text=\"item.statusStr\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p class=\"equipments-detail\" v-for=\"subItem in item.equipments\"&gt; &lt;span v-text=\"subItem.type+'安装'\"&gt;&lt;/span&gt; &lt;span v-text=\"subItem.brand+subItem.productNo\"&gt;&lt;/span&gt; &lt;span v-text=\"subItem.installWay\"&gt;&lt;/span&gt; &lt;span v-text=\"'费用：'+item.price+'元'\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;p v-text=\"item.createTime+'下单'\"&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 12345678toStatusPage: function(event)&#123; var target = event.target; while(target.tagName != 'LI')&#123; target = target.parentNode; &#125; var id = target.getAttribute('orderId'); window.location.href = Utils.baseUrl + '/html/orderStatus.html?id='+id; &#125; 很简单的一个列表进详情，为了节省内存，使用了代理的方式，用ul来代理事件，最初的想法是li点击的时候获取他的orderId，然后跳转到对应的详情页，当使用代理方式拿到的target可能是span，也可能是p，如果层级很多就很可能是别的什么了。那么这里得想法吧拿到li，所以使用了parentNode这个东东，去判断li在哪，用了一个简单的循环，拿到li后结束循环，执行后面的操作，暂时这样解决了，还没有想到更好的方法，有更好的方法的朋友欢迎留言，让大家都学习下，谢啦！ 好了，暂时就总结这么多吧，文中如有错误之处麻烦指正，谢谢！","tags":[{"name":"js","slug":"js","permalink":"https://yl.frontjs.cc/tags/js/"},{"name":"微信","slug":"微信","permalink":"https://yl.frontjs.cc/tags/微信/"}]},{"title":"addEvent和removeEvent","date":"2016-03-21T09:38:46.000Z","path":"2016/03/21/2016-03-21-add-event/","text":"最近在看《精通JavaScript》这本书，感觉还不错，这里记录下里面的事件监听与移除的方法，以备日后开发时参考。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function addEvent(element, type, handler)&#123; //为每一个事件处理函数赋予一个独立的ID if(!handler.$$guid)&#123; handler.$$guid = addEvent.guid++; &#125; //为元素建立一个事件类型的散列表 if(!element.events)&#123; element.events = &#123;&#125;; &#125; //为每对元素/事件建立一个事件处理函数的散列表 var handlers = element.events[type]; if(!handlers)&#123; handlers = element.events[type] = &#123;&#125;; //存储已有的事件处理函数(如果已存在一个) if(element[\"on\"+type])&#123; handlers[0] = element[\"on\"+type]; &#125; &#125; //在散列表中存储该事件处理函数 handlers[handler.$$guid] = handler; //赋予一个全局事件处理函数来处理所有工作 element[\"on\"+type] = handleEvent;&#125;;//创建独立ID的计数器addEvent.guid = 1;function removeEvent(element, type, handler)&#123; //从散列表中删除事件处理函数 if(element.events &amp;&amp; element.events[type])&#123; delete element.events[type][handler.$$guid]; &#125;&#125;function handleEvent(event)&#123; var returnValue = true; //获取事件对象(IE使用全局的事件对象) event = event || fixEvent(window.event); //获取事件处理函数散列表的引用 var handlers = this.events[event.type]; //依次执行每个事件处理函数 for(var i in handlers)&#123; this.$$handleEvent = handlers[i]; if(this.$$handleEvent(event) === false)&#123; returnValue = false; &#125; &#125; return returnValue;&#125;;//增加一些IE事件对象的缺乏的方法function fixEvent(event)&#123; //增加W3C标准事件方法 event.preventDefault = fixEvent.preventDefault; event.stopPropagation = fixEvent.stopPropagation; return event;&#125;;fixEvent.preventDefault = function()&#123; this.returnValue = false;&#125;;fixEvent.stopPropagation = function()&#123; this.cancelBulle = true;&#125;/*test*/ addEvent(document.body, \"click\", function()&#123; console.log('a');&#125;)document.body.click();","tags":[{"name":"js","slug":"js","permalink":"https://yl.frontjs.cc/tags/js/"}]},{"title":"宏碁4752g换ssd，光驱位装硬盘(多图慎入)","date":"2016-03-14T09:38:27.000Z","path":"2016/03/14/2016-03-14-note-ssd/","text":"背景笔记本已经买了4年了，最近特别卡，打开IDE都要等半天，近期也没有换笔记本的打算，就索性换个ssd吧 拆硬盘换ssd 准备：笔记本，工具箱，ssd，硬盘托架 打开笔记本后盖，可以看到硬盘，拆下固定硬盘的几个螺丝，如图 拆下硬盘 将ssd装在硬盘位 盖上硬盘固定盖，上好螺丝 盖上笔记本后盖，ssd就装好了 光驱位装硬盘现在光驱的作用越来越小了，刚才从笔记本下下来的机械硬盘可以作为笔记本的存储，ssd就用来装系统装软件，所以可以将光驱拆下来，把空间留给硬盘 拆光驱：拧下固定光驱的螺丝，如图，然后用针(买硬盘托架一般都会送一个细小的工具)在里面捅一下，同时稍微用点力往外拉光驱，光驱就拆下来了 硬盘托架和光驱对比 将硬盘放入托架，把原光驱边沿的小盖条拆下装在硬盘托架上，然后放入光驱位，一切就ok了 后记全部弄好后，开机，F2，开机首选项设置为光驱位的硬盘（也就是进入原来的操作系统），开机后在磁盘管理可以看到ssd的未分配的空间，就说明ssd安装成功，硬盘也在光驱位正常使用了。然后就是将系统安装在ssd，并设置ssd为第一启动项了。安装系统的内容这里就不多说了，网上很多教程。 本教程就说到这里，大家有什么问题欢迎留言。","tags":[{"name":"ssd","slug":"ssd","permalink":"https://yl.frontjs.cc/tags/ssd/"}]},{"title":"关于javascript函数声明提升和变量声明提升","date":"2016-03-12T09:37:36.000Z","path":"2016/03/12/2016-03-13-define-upgrade/","text":"一直知道javascript变量和函数都会在自己的作用于内声明提升，但是当变量名和函数名相同时，谁会覆盖谁呢？ 1234alert(a);var a = 1;function a()&#123;&#125;;alert(a); 结果：function a(){} 1 1234alert(a);function a()&#123;&#125;;var a = 1;alert(a); 结果：function a(){} 1 1234alert(a);function a()&#123;&#125;;var a;alert(a); 结果：function a(){} function a(){} 结论：同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值就是变量的值","tags":[{"name":"js","slug":"js","permalink":"https://yl.frontjs.cc/tags/js/"}]},{"title":"CRM前端架构分享","date":"2016-03-09T09:36:27.000Z","path":"2016/03/09/2016-03-09-crm-share/","text":"crm-app 开发工具：hbuilder 使用的技术：mui arttemplate.js h5+ native.js 参考文档 详细讲解 项目结构 mainfist.json 配置 应用信息 图标，启动图片 sdk(关键点) 模块权限(关键点) 版本升级 修改manifest.json文件的版本号 修改update.json文件的版本号，以及更新资源路径 开发中常用功能及填坑方法 下拉刷新+上拉加载 html结构 12345&lt;div id=\"refreshContainer\" class=\"mui-content mui-scroll-wrapper\"&gt; &lt;div class=\"mui-scroll\"&gt; &lt;/div&gt;&lt;/div&gt; js代码 1234567891011121314$.init(&#123; pullRefresh:&#123; container:'#refreshContainer', down: &#123; contentdown : \"下拉可以刷新\", contentover : \"释放立即刷新\", contentrefresh : \"正在刷新...\", callback:process.pullDownList &#125;, up: &#123; callback: process.pullUpList &#125; &#125;&#125;); 页面跳转 页面类型：组装页面 独立页面 (举个栗子 return模块)跳转页面事件触发：fire mui.back() 相关sdk (地图、复制、粘贴、文件上传、拍照、分享) 调试，直接连手机 打包 （云端打包生成apk和ipa文件） ios打包需要相关账号信息及证书(开发证书有过期时间)，android可以使用dcloud的公用证书也可以用自己的证书 全局方法 常用的方法可以写在app.js在(公共文件)文件中，比如全局ajax等 crm-pc 开发工具 ：webstorm 插件配置：scss（配置后，sass自动转css） 开发环境搭建： 安装nodejs，推荐4.2以上版本 安装gulp，构建工具 安装其他打包插件(package.json已经配置好构建插件的依赖，直接执行npm install即可安装，安装不了，请翻墙) 项目结构 开发规范 js、css、html、等资源单独文件夹放置 一个模块一个文件夹，每种资源都一致，css(scss文件)资源统一引入公共样式 @import &quot;../subBase&quot;; body标签统计加上类名为模块名字，方便构建后特殊样式区分 暂时没做依赖管理，按需引入组件：库-&gt;插件(组件)-&gt;自定义 开发目录src，发布目录dist UI及库 ui使用bootstrap，引入jquery主要是为了支持bootstrap 使用vue.js vue常用功能介绍 数据绑定，计算属性，方法绑定，属性，组件化(stateAnalysis模块) 构建方法及常用gulp插件：(见gulpfile文件) 其他","tags":[{"name":"crm","slug":"crm","permalink":"https://yl.frontjs.cc/tags/crm/"}]},{"title":"关于js异步上传文件","date":"2016-03-08T09:34:59.000Z","path":"2016/03/08/2016-03-08-file-upload/","text":"本文首发在我的博客园：https://www.cnblogs.com/yuanlong1012/p/5127497.html 最近项目里有个需求，上传文件（好吧，这种需求很常见，这也不是第一次遇到了）。当时第一想法就是直接用form表单提交（原谅我以前就是这么干的），不过表单里不仅有文件还有别的信息需要交互，跟后端商量后决定文件单独上传，获取到服务器端返回的文件地址在和表单一起提交。这里就需要异步上传文件。 在网上扒了扒相关的内容，发现还真不少，阮一峰老师的这篇文章文件上传的渐进式增强就介绍的很具体，下面就谈谈自己在实战中遇到的一些问题的感受吧。 先看看效果，实现了哪些功能 （好吧，就一个按钮而已，搞得神神秘秘，嘿嘿） 1&lt;button type=\"button\" class=\"btn\" @click=\"upload\"&gt;点击上传文件&lt;/button&gt; 给按钮绑定了一个点击事件，下面看看点击事件方法里做了什么 1234567891011121314151617181920methods: &#123; upload: function()&#123; myUpload(&#123; url: window.location.protocol + '//' + window.location.host + '/crm/upload', maxSize: 10, beforeSend: function(file)&#123; &#125;, callback: function(res)&#123; var data = JSON.parse(res); pageCont.attachmentUrl = data.url; &#125;, uploading: function(pre)&#123; pageCont.uploadCont.display = 'block'; pageCont.uploadStyle.width = pre * 2 + 'px'; pageCont.pre = pre; &#125; &#125;); &#125;&#125; 按钮绑定的点击事件执行了upload方法，在upload方法里调用了一下myUpload方法，并传递了一些配置信息进去，稍后说下这些配置信息。先看看myUpload的具体实现： 初始化了一个FormData对象和一个XMHttpResquest对象，创建一个type为file的input，并触发一次该input的click，如下 12345678910var fd = new FormData(), xhr = new XMLHttpRequest(), input;input = document.createElement('input');input.setAttribute('id', 'myUploadInput');input.setAttribute('type', 'file');input.setAttribute('name', 'file');document.body.appendChild(input);input.style.display = 'none';input.click(); 监听刚才创建的input的change事件，并作在里面做相应处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445input.onchange = function()&#123; if(!input.value)&#123;return;&#125; if(option.maxSize &amp;&amp; input.files[0].size &gt; option.maxSize * 1024 * 1024)&#123; dialog(&#123; title: '提示', content: '请上传小于'+option.maxSize+'M的文件', okValue: '确定', ok: function () &#123;&#125; &#125;).showModal(); return; &#125; if(option.beforeSend instanceof Function)&#123; if(option.beforeSend(input) === false)&#123; return false; &#125; &#125; fd.append('file', input.files[0]); xhr.open('post', option.url); xhr.onreadystatechange = function()&#123; if(xhr.status == 200)&#123; if(xhr.readyState == 4)&#123; if(option.callback instanceof Function)&#123; option.callback(xhr.responseText); &#125; &#125; &#125;else&#123; if(!(dialog.get('uploadfail')))&#123; dialog(&#123; id: 'uploadfail', title: '提示', content: '上传失败', okValue: '确定', ok: function () &#123;&#125; &#125;).showModal(); &#125; &#125; &#125; xhr.upload.onprogress = function(event)&#123; var pre = Math.floor(100 * event.loaded / event.total); if(option.uploading instanceof Function)&#123; option.uploading(pre); &#125; &#125; xhr.send(fd);&#125; 解释下上面的代码。input的change事件触发后，首先判断了下当前是否选择了文件 1if(!input.value)&#123;return;&#125; 一开始我是没做这个判断的，在后来的测试过程中发现，当上传一次文件后，再次点击按钮上传，打开文件选择框，然后不选择文件，而是点击取消按钮，change事件也触发了，导致后面的代码也会执行，显然这不合理，故加了这个判断。 然后限制了下上传文件的大小（这样的事能够前端处理就不要交给服务端来验证了），当文件大小超过最大限制，就会弹框提示 123456789if(option.maxSize &amp;&amp; input.files[0].size &gt; option.maxSize * 1024 * 1024)&#123; dialog(&#123; title: '提示', content: '请上传小于'+option.maxSize+'M的文件', okValue: '确定', ok: function () &#123;&#125; &#125;).showModal(); return;&#125; 然后加了一个文件上传前的操作，可以在文件上传前做一些处理，如进度条的显示，图片预览等等 12345if(option.beforeSend instanceof Function)&#123; if(option.beforeSend(input) === false)&#123; return false; &#125;&#125; 接下来将文件append到formData对象里，使用字段名‘file’，该字段名是服务端接收文件时使用的字段名 1fd.append('file', input.files[0]); 然后就是使用XMLHttpRequest对象向服务端发送数据了 123456789101112131415161718192021222324252627xhr.open('post', option.url);xhr.onreadystatechange = function()&#123; if(xhr.status == 200)&#123; if(xhr.readyState == 4)&#123; if(option.callback instanceof Function)&#123; option.callback(xhr.responseText); &#125; &#125; &#125;else&#123; if(!(dialog.get('uploadfail')))&#123; dialog(&#123; id: 'uploadfail', title: '提示', content: '上传失败', okValue: '确定', ok: function () &#123;&#125; &#125;).showModal(); &#125; &#125;&#125;xhr.upload.onprogress = function(event)&#123; var pre = Math.floor(100 * event.loaded / event.total); if(option.uploading instanceof Function)&#123; option.uploading(pre); &#125;&#125;xhr.send(fd); 再向服务端发送数据时，使用了监听了一下progress事件，主要是为了进行上传进度的显示，上述代码中， 1var pre = Math.floor(100 * event.loaded / event.total); 获取上传的百分比，能够拿到这个值，页面上就可以展示各种各样的上传进度效果了。 差不多介绍完了，下面补充一下使用中遇到的问题： 问题一：文件在上传的过程中，使用JSON.parse()序列化服务端返回的json字符串报错(傻啊，文件还在上传，服务端怎么会返回数据啊)。 事情是这样的，一开始，我在readystatechange里只监听了状态码是否是200，如果是就说明通了，然后执行回调，在回调里处理服务端返回的数据，但是通了不一定代表服务端已经返回了数据，所以就出现了上面的错误，所以后来在判断了status是否为200后，还判断了readyState，以确保服务端已处理完毕并返回数据在执行回调 12345if(xhr.status == 200)&#123; if(option.callback instanceof Function)&#123; option.callback(xhr.responseText); &#125;&#125; 问题二：重复创建input。每次点击按钮上传文件后，页面都会多一个type=file的input感觉不是很好（个人癖好吧），所以对最开始的初始化代码做了下优化，判断当前页面是否存在刚才创建的input，存在就直接使用，不存在就创建，如下 12345678910if(document.getElementById('myUploadInput'))&#123; input = document.getElementById('myUploadInput');&#125;else&#123; input = document.createElement('input'); input.setAttribute('id', 'myUploadInput'); input.setAttribute('type', 'file'); input.setAttribute('name', 'file'); document.body.appendChild(input); input.style.display = 'none';&#125; 好了，就这么多了。看看效果 刚才加了个需求，限制上传文件类型，作了如下修改： myUpload方法，初始化时增加了支持文件类型，如下 1fileType = ['doc','docx','xls','xlsx','pdf','jpg','png','ppt','pptx'] change发生后，检查文件类型，如下 12345678910var type = input.value.split('.').pop();if(fileType.indexOf(type.toLocaleLowerCase()) == -1)&#123; dialog(&#123; title: '提示', content: '暂不支持该类型的文件，请重新选择!', okValue: '确定', ok: function () &#123;&#125; &#125;).showModal(); return;&#125; 因个人知识面有限，如有错误，还请指正。","tags":[{"name":"js","slug":"js","permalink":"https://yl.frontjs.cc/tags/js/"},{"name":"文件上传","slug":"文件上传","permalink":"https://yl.frontjs.cc/tags/文件上传/"}]},{"title":"chrome使用技巧之snippets","date":"2016-03-06T09:36:00.000Z","path":"2016/03/06/2016-03-06-chrome-tip-snippets/","text":"在平时开发中，使用的最多的工具应该是chrome了(前端而言)，chrome有很多使用技巧，下面我们要聊的正是snippets,个人认为比控制台的console好用(也只是在某些场景下面)。 例如平时浏览博客园等网站时，看到某些大神写的一些很高大上的代码，想亲手实践下正确性，或是想调试下，那么一般人都会打开sublime等开发工具，建一个页面文档，在script标签里粘贴或者敲出那一坨js(也有可能在js里加几个console.log)，然后在浏览器打开，F12，看控制台信息，如果需要调试也可能在source里找到文件打上断点。 回顾下刚才描述的过程，不免觉得有点麻烦。也有人说直接在浏览器的控制台里进行码代码，enter后就可以看到结果了。没错，要看结果这或许是很方便，可是，如果要对代码进行调试呢? 这里就要请出我们的snippets了。snippets在哪？请看下面截图 看了上面的图片，各位看官应该已经了了解了如何使用snippets了，在空白区域右键选择new可以新建文件，右键刚才新建的文件选择run可以运行写的测试代码，断点的方法这里就不多介绍了，相信使用chrome开发的朋友都应该很熟了。 关于snippets就介绍这么多，chrome里找不到snippets的同学可以去升级一下浏览器。 其实chrome的使用技巧还有很多，比如workspace，这里顺带提一下，也不单独弄篇文章讨论了。请看下图 没错，找到地方后，右键就可以看到这个workspace了，这个是干嘛的？这个是把你本地的资源加载到当前站点，说明白点就是“js”注入(胡乱取的名字)，具体的就不展开了，有兴趣的同学可以去实践下。","tags":[{"name":"chrome","slug":"chrome","permalink":"https://yl.frontjs.cc/tags/chrome/"},{"name":"snippets","slug":"snippets","permalink":"https://yl.frontjs.cc/tags/snippets/"}]},{"title":"使用jekyll搭建博客及jekyll模板easybook使用方法","date":"2016-03-05T09:34:10.000Z","path":"2016/03/05/2016-03-05-build-jekyll-blog/","text":"网上关于在github上搭建静态博客的文章很多，也很详细，这里只是简单记录下本站的搭建过程。 在github上创建一个项目，项目名为username.github.io，username就是你github的名字，然后一步步的按提示操作… 不想自己折腾的话可以选择博客模板，刚才在github上创建项目并autoloadpage后是可以选择模板的，我们也可以在网上找jekyll的相关模板，这里我选择的是easybook 下载easybook后，将其文件拷贝到你本地的username.github.io下（先要clone你刚才在github上建的项目） 安装ruby、gem、jekyll（自行百度）,然后本地启动查看效果，浏览器打开127.0.0.1:4000就可以看到效果 1jekyll server 对easybook模板进行修改下面按照自己的需求个性化一下这个模板。所谓的个性化，指的是根据刚才显示的效果查看对应的文件，了解页面的显示方式所对应的编写方法（原谅我没有深入的究其原理，只是研究了这套模板而已）。 先看_config.yml文件，这里面定义的东东简单理解就是定义的全局的变量，然后其他文件可以使用，这里我也不介绍很仔细了，简单的提下自己改的地方。title:网站标题description:描述，seo用的，生成的页面里的meta标签里可以看到avatar:头像对应的图片地址，当然也可以将图片放在项目里引入或者直接修改sidebar.html里的头像地址其他对应参数的修改可以看下面我的github上该项目的具体修改 发布文章之前看网上的，使用markdown语法编写好博客后，还需要执行jekyll的相关命令进行生产对应的文档，但是我这里没有这么做。文章在本地写好后使用jekyll server进行本地预览，预览成功后，直接将本地修改push到github上就可以了，直接使用master分支，文档的类型是markdown不是md，否则上传后不显示(md类型的文档本地是可以预览显示的，具体原因还不知)，还要注意文档的日期格式。 结语感觉使用jekyll来写静态博客还是蛮方便的，这也给了懒人一个写博客的理由 - - 当然，easybook里文章的分页以及分类都已经实现了，每篇md文档最上边的categories就是分类标识，也可以一篇文章处于多个分类里。关于博客的评论功能有时间再看看怎么引入。希望自己能将这个习惯坚持下去 附上修改后的项目的github地址，https://github.com/YL2014/YL2014.github.io，欢迎Star","tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://yl.frontjs.cc/tags/jekyll/"},{"name":"blog","slug":"blog","permalink":"https://yl.frontjs.cc/tags/blog/"}]}]